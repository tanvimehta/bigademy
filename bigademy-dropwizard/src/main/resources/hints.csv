exercise_id,hint_id,hint1,1,The solution for this exercise has been provided to you. Please press the run button at the bottom to continue.2,2,Calculate the sum of the marks as mark1 + mark2 + mark32,3,"Use ""mark1 + mark2 + mark3 as total"" to store the sum of marks as ""total"""3,4,Use FOREACH...GENERATE to create a relation containing studentID and average marks.3,5,"Since each student has exactly 3 marks, average can be calculated as (mark1+mark2+mark3)/3."3,6,"To ensure that studentID is not null, use the expression ""studentID IS NOT null"""3,7,Make sure your FILTER operator only returns tuples with mark between 50 and 70.4,8,"Each of the 3 marks within the tuple mark can be dereferenced as mark.mark1, mark.mark2 and so on."4,9,Make sure the order of your fields in the FOREACH..GENERATE matches that of the expected output.5,10,Use AVG function to calculate the average marks.5,11,Think about how courseAndMarkInfo can be used to reference marks.6,12,"Since we want to group the students with the same total mark over the same semester, GROUP BY totalMark, semester."6,13,"Dereference the semester and total mark using the fact that these fields would be stored as ""group"" in the output of the GROUP BY relation."6,14,Dereference studentID using the fact that it is a field from the input data set.7,15,Use the name of the fields to reference them and generate the expected output.8,16,Use the name of the fields to reference them and generate the expected output.9,17,"Since the resulting relation should only contain courses with matching values in both tables, use inner join."10,18,"Since the resulting relation should also contain courses with no matching tuples in the marks table, we can use OUTER JOIN."11,19,"Since the relation should contain students in the marks table with no matching tuples in the courses table, we can use OUTER JOIN."12,20,"Since the resulting relation should contain all the tuples with no matching fields in the other relation, we can use OUTER JOIN."13,21,"Since we need a list of students and marks for each course, we can GROUP BY courseID."14,22,"Since we have to calculate the average for each course, we can GROUP BY courseID to get all the marks for a particular course."14,23,For each course we have to add a tuple to our resulting relation with the courseID and average mark. This can be done using FOREACH...GENERATE statement.15,24,"Marks are stored in fields mark1, mark2 and mark3. We can use these field names to calculate the average."15,25,"Since all the students should be grouped according to their averages, we can use the average as the group by clause."16,26,"We need a list of students who scored the same mark for the same course, this can be done by grouping the relation by both courseID and mark."17,27,"Since we have to find students scoring more than 70 in each course, we can group by courseID."17,28,"For each course, we have to list the students according to a given condition. This is a task for FOREACH..GENERATE"17,29,We need to find students with mark greater than 70. FILTER operator with mark>70 can be used for this purpose.18,30,Use the common fields from the two datasets to get the final desired result.18,31,Use an operator to work on each column of the dataset.18,32,Use an operator that can get rid of the additional brackets around the professor name.21,37,"To get the top 3 marks, we can use ORDER BY to order the marks in descending order."21,38,The LIMIT operator can give us a relation with exactly 3 tuples.23,39,"Since studentsData1 has the schema of the desired result, we can use the ONSCHEMA operator on relation studentsData1."22,40,Pay attention to the order of the tuples in the output dataset.